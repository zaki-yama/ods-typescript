第2章 配列を使ったリスト
=====================

backing arrayは単に配列arrayと読み替えてよい

データを1つの配列に入れて動作するデータ構造のメリット・デメリット

- メリット
  - 任意の要素に一定時間でアクセスできる
- デメリット
  - それほど動的でない。要素の追加・削除は、隙間を作ったり埋めたりするため、配列中の多くの要素を移動させる必要がある
  - `add(i,x)`と`remove(i)`操作の実行時間がnとiに依存するのはこれが原因
  - 伸び縮みしない。arrayのサイズより多くの要素をデータ構造に入れるには、新しい配列を割り当てて古い配列の要素をそちらにコピーしなければならない


### 2.1 ArrayStack: 配列を使った高速なスタック操作
- ArrayStack: backing arrayを使ったListインターフェースの実装
- 償却解析(amortized analysis)

- [✅] add(i, x)およびremove(i)の実行時間は O(1 + n - i) なのはなぜ？ +1 の部分は？
  - resize()の実行時間がm個のadd/removeの操作に対してO(m)なので、平均すると償却実行時間はO(1)。これをadd/remove自体の実行時間O(n-i)に足したから



### 2.3 ArrayQueue: 配列を使ったキュー
FIFO キューの実装にArrayStackを使うのは好ましくない。
理由：先頭か末尾のいずれかを要素を追加する側に、他方を削除する側に選ばなければならず、2つの操作のいずれかがリストの先頭を変更することになる。

無限長の配列ならキューを簡単に実装できるが、現実的には不可能。
かわりに、剰余算術(余り。mod)を使う。

- 配列の容量 `a`
- キューの要素数 `n`
- 次に削除する要素のインデックス `j`

とすると、

```
a[j%a.length], a[(j+1)%a.length], ... , a[(j+n-1)%a.length]
```

がキューの表現となる。

各実行時間

- add(x): O(1)
- remove(): O(1)
- resize(): m回のadd/removeの操作を実行したとき、実行時間の合計はO(m)
