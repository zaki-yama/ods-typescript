第1章 イントロダクション
=====================

### 1.2 インターフェース
- インターフェース(抽象データ型)：データ構造が何をするか
- 実装：データ構造がそれをどのようにやるか

#### 1.2.1 Queue, Stack, Deque インターフェース
- Queue
  - FIFO(first-in-first-out)
    - イメージ:コンビニのレジに並ぶ列
  - priority queue
    - イメージ:病院の救急室で重症患者を優先的に治療する場面
  - LIFO(last-in-first-out): Stackのこと
    - イメージ:皿を積んだ状態
- Deque
  - FIFOキューとStackを一般化したインターフェース
  - `addFirst(x)`, `removeFirst()`, `addLast(x)`, `removeLast()`という操作がある
    - `addLast(x)`と`removeFirst()`を使えばFIFOキュー
    - `addFirst(x)`と`removeFirst()`を使えばStack

#### 1.2.2 Listインターフェース：線形シーケンス
- Queue, Stack, DequeというインターフェースはListインターフェースとしてまとめられる
- Listインターフェースの操作
  - `size()`
  - `get(i)`
  - `set(i,x)`
  - `add(i,x)`
  - `remove(i)`

#### 1.2.3 USetインターフェース：順序付けられていない要素の集まり
- Uはunorderedの意味
- 要するに集合。set
- USetの操作
  - `size()`
  - `add(x)`
    - 要素xが集合に入っていなければ集合に追加する
    - x = yを満たす集合の要素yが存在しなければ、集合にxを加える
  - `remove(x)`
    - x = yを満たす...
  - `find(x)`
    - x = yを満たす...

- なぜ探したいxと見つかる(かもしれない)要素yを区別しているのか
  - 別のものであるxとyを、何らかの基準で等しいと判定したい場合があるから
  - そのような判定ができると、キーを値に対応付けるインターフェース(辞書やマップ)を実装するのに都合がいい

#### 1.2.4 SSetインターフェース:ソートされた要素の集まり
- Sはsortedの意味
- SSetには全順序集合 = 任意の2つの要素xとyについて大小を比較できるような集合　が入る
- サポートされる操作はUSetと同じ
- 違いは `find(x)`
  - 順序付けられた集合からy>=xを満たす

### 1.3 数学的背景

#### 1.3.3 漸近記法(asynmptotic notation)
- ビッグオー記法のこと

ある関数 `f(n)` について、次のように定義される関数の集合 `O(f(n))` を考える

O(f(n)) = { g(n): ある c > 0 と n0 が存在し、
任意の n >= n0 について g(n) <= c * f(n) を満たす }

...(よくわからなくなったので後で)

### 1.4 計算モデル
- あとで読む

### 1.5 正しさ、時間計算量、空間計算量
- データ構造に対して実行時間を議論するときは、次の三種類のいずれかを保証するという話になることが多い
  - 最悪実行時間
    - あるデータ構造の操作について最悪実行時間が f(n) であるといったら、そのような操作の実行時間が f(n) より長くなることは決してない
  - 償却実行時間
    - 典型的な操作にかかるコストが f(n) を超えない
    - いくつかの操作は f(n) を超えるかもしれないが、操作の列全体として考えれば、1つあたりの実行時間は f(n)
  - 期待実行時間
    - 実行時間が確率変数で、その確率変数の期待値が f(n) である
  